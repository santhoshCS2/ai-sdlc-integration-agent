import os
import httpx
import base64
import json
import logging
import asyncio
from typing import Dict, Optional
from datetime import datetime

logger = logging.getLogger(__name__)

class GitHubIntegrationService:
    def __init__(self):
        self.name = "GitHub Integration Service"
        self.github_token = os.getenv("GITHUB_TOKEN")
        self.base_url = "https://api.github.com"
        self.headers = {
            "Accept": "application/vnd.github.v3+json",
            "Content-Type": "application/json"
        }
        if self.github_token:
            self.headers["Authorization"] = f"token {self.github_token}"

    def set_token(self, token: str):
        """Dynamically set the GitHub token and update headers."""
        if not token:
            return
        self.github_token = token
        self.headers["Authorization"] = f"token {token}"
        print(f"[GitHub] Token updated successfully.")

    async def create_or_update_repository(self, repo_name: str, description: str = "Auto-generated SDLC project") -> Optional[str]:
        """Create a new GitHub repository using the provided token."""
        try:
            if not self.github_token:
                logger.warning("[GitHub] No token provided. Skipping repository creation.")
                return None
            
            async with httpx.AsyncClient() as client:
                # 1. Get authenticated user's login to avoid hardcoding "user"
                user_response = await client.get(
                    f"{self.base_url}/user",
                    headers=self.headers
                )
                
                if user_response.status_code != 200:
                    logger.error(f"[GitHub] Authentication failed: {user_response.status_code}")
                    return None
                
                username = user_response.json().get("login")
                
                # 2. Try to create repository
                repo_data = {
                    "name": repo_name,
                    "description": description,
                    "private": False,
                    "auto_init": True
                }
                
                response = await client.post(
                    f"{self.base_url}/user/repos",
                    headers=self.headers,
                    json=repo_data
                )
                
                if response.status_code == 201:
                    repo_info = response.json()
                    print(f"[GitHub] Repository created successfully: {repo_info['html_url']}")
                    return repo_info['html_url']
                elif response.status_code == 422:
                    # Repository already exists
                    print(f"[GitHub] Repository '{repo_name}' already exists at https://github.com/{username}/{repo_name}")
                    return f"https://github.com/{username}/{repo_name}"
                else:
                    error_msg = response.json().get('message', 'Unknown error')
                    print(f"[GitHub] Failed to create repository: {response.status_code} - {error_msg}")
                    return None
                    
        except Exception as e:
            logger.error(f"[GitHub] Error creating repository: {e}")
            return None

    async def push_agent_outputs(self, repo_url: str, agent_outputs: Dict[str, str]) -> Dict[str, str]:
        """Push all agent outputs to the specified GitHub repository."""
        try:
            if not self.github_token:
                return {"error": "No GitHub token provided. Cannot push files."}
            
            owner, repo = self._sanitize_repo_parts(repo_url)
            if not owner or not repo:
                raise ValueError(f"Invalid repository URL: {repo_url}")
            
            async with httpx.AsyncClient() as client:
                pushed_files = {}
                
                # Push each agent output
                for agent_name, output_content in agent_outputs.items():
                    file_path = f"outputs/{agent_name}_output.md"
                    # Add meaningful header
                    file_content = f"# {agent_name.replace('_', ' ').upper()} REPORT\n\n{output_content}\n\n---\n*Generated by coastalsevel SDLC Agent*"
                    
                    success = await self._create_file(client, owner, repo, file_path, file_content)
                    if success:
                        pushed_files[agent_name] = f"https://github.com/{owner}/{repo}/blob/main/{file_path}"
                
                return pushed_files
                
        except Exception as e:
            logger.error(f"[GitHub] Error pushing agent outputs: {e}")
            return {"error": str(e)}

    def _sanitize_repo_parts(self, repo_url: str):
        """Extract owner and repo name from URL safely, stripping .git if present."""
        try:
            # Handle different URL styles
            clean_url = repo_url.replace("https://github.com/", "").replace(".git", "").strip("/")
            parts = clean_url.split("/")
            if len(parts) >= 2:
                return parts[0], parts[1]
            return None, None
        except:
            return None, None

    async def push_binary_file(self, repo_url: str, file_path: str, target_path: str, message: str = "Add binary file") -> bool:
        """Push a local binary file to GitHub."""
        try:
            if not self.github_token:
                logger.error("[GitHub] No token provided")
                return False
            
            owner, repo = self._sanitize_repo_parts(repo_url)
            if not owner or not repo:
                logger.error(f"[GitHub] Invalid repo URL: {repo_url}")
                return False
            
            if not os.path.exists(file_path):
                logger.error(f"[GitHub] Local file not found: {file_path}")
                return False
                
            async with httpx.AsyncClient(timeout=30.0) as client:
                # First, verify the repository exists
                repo_check = await client.get(
                    f"{self.base_url}/repos/{owner}/{repo}",
                    headers=self.headers
                )
                
                if repo_check.status_code != 200:
                    logger.error(f"[GitHub] Repository not found or not accessible: {owner}/{repo}")
                    logger.error(f"[GitHub] Response: {repo_check.status_code} - {repo_check.text}")
                    return False
                
                # Read file as binary
                with open(file_path, "rb") as f:
                    content = f.read()
                
                # GitHub has a 100MB file size limit via API
                if len(content) > 100 * 1024 * 1024:
                    logger.error(f"[GitHub] File too large: {len(content)} bytes (max 100MB)")
                    return False
                
                # Encode content
                b64_content = base64.b64encode(content).decode()
                
                # Check if file exists to get SHA
                get_response = await client.get(
                    f"{self.base_url}/repos/{owner}/{repo}/contents/{target_path}",
                    headers=self.headers
                )
                
                file_data = {
                    "message": message,
                    "content": b64_content
                }
                
                if get_response.status_code == 200:
                    existing_file = get_response.json()
                    file_data["sha"] = existing_file["sha"]
                    logger.info(f"[GitHub] Updating existing file: {target_path}")
                else:
                    logger.info(f"[GitHub] Creating new file: {target_path}")
                
                response = await client.put(
                    f"{self.base_url}/repos/{owner}/{repo}/contents/{target_path}",
                    headers=self.headers,
                    json=file_data
                )
                
                if response.status_code in [200, 201]:
                    logger.info(f"[GitHub] Successfully pushed binary file to {target_path}")
                    return True
                else:
                    logger.error(f"[GitHub] Failed to push binary file: {response.status_code}")
                    logger.error(f"[GitHub] Response: {response.text}")
                    return False
                    
        except Exception as e:
            logger.error(f"[GitHub] Error pushing binary file: {e}")
            import traceback
            traceback.print_exc()
            return False

    async def _create_file(self, client: httpx.AsyncClient, owner: str, repo: str, path: str, content: str) -> bool:
        """Helper to create/update files on GitHub via API."""
        try:
            # Check if file exists to get SHA
            get_response = await client.get(
                f"{self.base_url}/repos/{owner}/{repo}/contents/{path}",
                headers=self.headers
            )
            
            file_data = {
                "message": f"update {path} via SDLC orchestrator",
                "content": base64.b64encode(content.encode()).decode()
            }
            
            if get_response.status_code == 200:
                existing_file = get_response.json()
                file_data["sha"] = existing_file["sha"]
            
            response = await client.put(
                f"{self.base_url}/repos/{owner}/{repo}/contents/{path}",
                headers=self.headers,
                json=file_data
            )
            
            return response.status_code in [200, 201]
            
        except Exception as e:
            logger.error(f"[GitHub] Error in _create_file for {path}: {e}")
            return False

    async def push_local_directory(self, repo_url: str, local_path: str) -> Dict[str, str]:
        """Uploads an entire local folder to GitHub."""
        try:
            if not self.github_token:
                return {"error": "No token provided"}
            
            owner, repo = self._sanitize_repo_parts(repo_url)
            if not owner or not repo:
                return {"error": f"Invalid repo URL: {repo_url}"}
            pushed_files = {}
            
            async with httpx.AsyncClient(timeout=30.0) as client:
                for root, _, files in os.walk(local_path):
                    for file in files:
                        full_path = os.path.join(root, file)
                        # Skip large binary files or .git folders
                        if '.git' in full_path or '__pycache__' in full_path:
                            continue
                            
                        relative_path = os.path.relpath(full_path, local_path).replace("\\", "/")
                        
                        try:
                            with open(full_path, "rb") as f:
                                # Standardize encoding or use base64 for binary
                                content = f.read()
                                # Convert to base64 string
                                b64_content = base64.b64encode(content).decode()
                                
                            # Check if file exists
                            get_url = f"{self.base_url}/repos/{owner}/{repo}/contents/{relative_path}"
                            get_resp = await client.get(get_url, headers=self.headers)
                            
                            file_payload = {
                                "message": f"Upload {relative_path}",
                                "content": b64_content
                            }
                            
                            if get_resp.status_code == 200:
                                file_payload["sha"] = get_resp.json()["sha"]
                                
                            put_resp = await client.put(get_url, headers=self.headers, json=file_payload)
                            
                            if put_resp.status_code in [200, 201]:
                                pushed_files[relative_path] = f"{repo_url}/blob/main/{relative_path}"
                                # Small delay to be nice to GitHub API
                                await asyncio.sleep(0.1)
                            else:
                                logger.error(f"[GitHub] Failed to push {relative_path}: {put_resp.status_code} - {put_resp.text}")
                        except Exception as file_err:
                            logger.error(f"Failed to push {relative_path}: {file_err}")
            
            return pushed_files
        except Exception as e:
            logger.error(f"[GitHub] push_local_directory failed: {e}")
            return {"error": str(e)}

github_integration_service = GitHubIntegrationService()